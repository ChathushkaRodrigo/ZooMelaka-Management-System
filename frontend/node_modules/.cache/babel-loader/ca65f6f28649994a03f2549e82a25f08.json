{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformWebkitRadialGradientArgs = exports.parseGradient = exports.RadialGradient = exports.LinearGradient = exports.RADIAL_GRADIENT_SHAPE = exports.GRADIENT_TYPE = undefined;\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _NodeContainer = require('./NodeContainer');\n\nvar _NodeContainer2 = _interopRequireDefault(_NodeContainer);\n\nvar _Angle = require('./Angle');\n\nvar _Color = require('./Color');\n\nvar _Color2 = _interopRequireDefault(_Color);\n\nvar _Length = require('./Length');\n\nvar _Length2 = _interopRequireDefault(_Length);\n\nvar _Util = require('./Util');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar SIDE_OR_CORNER = /^(to )?(left|top|right|bottom)( (left|top|right|bottom))?$/i;\nvar PERCENTAGE_ANGLES = /^([+-]?\\d*\\.?\\d+)% ([+-]?\\d*\\.?\\d+)%$/i;\nvar ENDS_WITH_LENGTH = /(px)|%|( 0)$/i;\nvar FROM_TO_COLORSTOP = /^(from|to|color-stop)\\((?:([\\d.]+)(%)?,\\s*)?(.+?)\\)$/i;\nvar RADIAL_SHAPE_DEFINITION = /^\\s*(circle|ellipse)?\\s*((?:([\\d.]+)(px|r?em|%)\\s*(?:([\\d.]+)(px|r?em|%))?)|closest-side|closest-corner|farthest-side|farthest-corner)?\\s*(?:at\\s*(?:(left|center|right)|([\\d.]+)(px|r?em|%))\\s+(?:(top|center|bottom)|([\\d.]+)(px|r?em|%)))?(?:\\s|$)/i;\nvar GRADIENT_TYPE = exports.GRADIENT_TYPE = {\n  LINEAR_GRADIENT: 0,\n  RADIAL_GRADIENT: 1\n};\nvar RADIAL_GRADIENT_SHAPE = exports.RADIAL_GRADIENT_SHAPE = {\n  CIRCLE: 0,\n  ELLIPSE: 1\n};\nvar LENGTH_FOR_POSITION = {\n  left: new _Length2.default('0%'),\n  top: new _Length2.default('0%'),\n  center: new _Length2.default('50%'),\n  right: new _Length2.default('100%'),\n  bottom: new _Length2.default('100%')\n};\n\nvar LinearGradient = exports.LinearGradient = function LinearGradient(colorStops, direction) {\n  _classCallCheck(this, LinearGradient);\n\n  this.type = GRADIENT_TYPE.LINEAR_GRADIENT;\n  this.colorStops = colorStops;\n  this.direction = direction;\n};\n\nvar RadialGradient = exports.RadialGradient = function RadialGradient(colorStops, shape, center, radius) {\n  _classCallCheck(this, RadialGradient);\n\n  this.type = GRADIENT_TYPE.RADIAL_GRADIENT;\n  this.colorStops = colorStops;\n  this.shape = shape;\n  this.center = center;\n  this.radius = radius;\n};\n\nvar parseGradient = exports.parseGradient = function parseGradient(container, _ref, bounds) {\n  var args = _ref.args,\n      method = _ref.method,\n      prefix = _ref.prefix;\n\n  if (method === 'linear-gradient') {\n    return parseLinearGradient(args, bounds, !!prefix);\n  } else if (method === 'gradient' && args[0] === 'linear') {\n    // TODO handle correct angle\n    return parseLinearGradient(['to bottom'].concat(transformObsoleteColorStops(args.slice(3))), bounds, !!prefix);\n  } else if (method === 'radial-gradient') {\n    return parseRadialGradient(container, prefix === '-webkit-' ? transformWebkitRadialGradientArgs(args) : args, bounds);\n  } else if (method === 'gradient' && args[0] === 'radial') {\n    return parseRadialGradient(container, transformObsoleteColorStops(transformWebkitRadialGradientArgs(args.slice(1))), bounds);\n  }\n};\n\nvar parseColorStops = function parseColorStops(args, firstColorStopIndex, lineLength) {\n  var colorStops = [];\n\n  for (var i = firstColorStopIndex; i < args.length; i++) {\n    var value = args[i];\n    var HAS_LENGTH = ENDS_WITH_LENGTH.test(value);\n    var lastSpaceIndex = value.lastIndexOf(' ');\n\n    var _color = new _Color2.default(HAS_LENGTH ? value.substring(0, lastSpaceIndex) : value);\n\n    var _stop = HAS_LENGTH ? new _Length2.default(value.substring(lastSpaceIndex + 1)) : i === firstColorStopIndex ? new _Length2.default('0%') : i === args.length - 1 ? new _Length2.default('100%') : null;\n\n    colorStops.push({\n      color: _color,\n      stop: _stop\n    });\n  }\n\n  var absoluteValuedColorStops = colorStops.map(function (_ref2) {\n    var color = _ref2.color,\n        stop = _ref2.stop;\n    var absoluteStop = lineLength === 0 ? 0 : stop ? stop.getAbsoluteValue(lineLength) / lineLength : null;\n    return {\n      color: color,\n      // $FlowFixMe\n      stop: absoluteStop\n    };\n  });\n  var previousColorStop = absoluteValuedColorStops[0].stop;\n\n  for (var _i = 0; _i < absoluteValuedColorStops.length; _i++) {\n    if (previousColorStop !== null) {\n      var _stop2 = absoluteValuedColorStops[_i].stop;\n\n      if (_stop2 === null) {\n        var n = _i;\n\n        while (absoluteValuedColorStops[n].stop === null) {\n          n++;\n        }\n\n        var steps = n - _i + 1;\n        var nextColorStep = absoluteValuedColorStops[n].stop;\n        var stepSize = (nextColorStep - previousColorStop) / steps;\n\n        for (; _i < n; _i++) {\n          previousColorStop = absoluteValuedColorStops[_i].stop = previousColorStop + stepSize;\n        }\n      } else {\n        previousColorStop = _stop2;\n      }\n    }\n  }\n\n  return absoluteValuedColorStops;\n};\n\nvar parseLinearGradient = function parseLinearGradient(args, bounds, hasPrefix) {\n  var angle = (0, _Angle.parseAngle)(args[0]);\n  var HAS_SIDE_OR_CORNER = SIDE_OR_CORNER.test(args[0]);\n  var HAS_DIRECTION = HAS_SIDE_OR_CORNER || angle !== null || PERCENTAGE_ANGLES.test(args[0]);\n  var direction = HAS_DIRECTION ? angle !== null ? calculateGradientDirection( // if there is a prefix, the 0° angle points due East (instead of North per W3C)\n  hasPrefix ? angle - Math.PI * 0.5 : angle, bounds) : HAS_SIDE_OR_CORNER ? parseSideOrCorner(args[0], bounds) : parsePercentageAngle(args[0], bounds) : calculateGradientDirection(Math.PI, bounds);\n  var firstColorStopIndex = HAS_DIRECTION ? 1 : 0; // TODO: Fix some inaccuracy with color stops with px values\n\n  var lineLength = Math.min((0, _Util.distance)(Math.abs(direction.x0) + Math.abs(direction.x1), Math.abs(direction.y0) + Math.abs(direction.y1)), bounds.width * 2, bounds.height * 2);\n  return new LinearGradient(parseColorStops(args, firstColorStopIndex, lineLength), direction);\n};\n\nvar parseRadialGradient = function parseRadialGradient(container, args, bounds) {\n  var m = args[0].match(RADIAL_SHAPE_DEFINITION);\n  var shape = m && (m[1] === 'circle' || // explicit shape specification\n  m[3] !== undefined && m[5] === undefined) // only one radius coordinate\n  ? RADIAL_GRADIENT_SHAPE.CIRCLE : RADIAL_GRADIENT_SHAPE.ELLIPSE;\n  var radius = {};\n  var center = {};\n\n  if (m) {\n    // Radius\n    if (m[3] !== undefined) {\n      radius.x = (0, _Length.calculateLengthFromValueWithUnit)(container, m[3], m[4]).getAbsoluteValue(bounds.width);\n    }\n\n    if (m[5] !== undefined) {\n      radius.y = (0, _Length.calculateLengthFromValueWithUnit)(container, m[5], m[6]).getAbsoluteValue(bounds.height);\n    } // Position\n\n\n    if (m[7]) {\n      center.x = LENGTH_FOR_POSITION[m[7].toLowerCase()];\n    } else if (m[8] !== undefined) {\n      center.x = (0, _Length.calculateLengthFromValueWithUnit)(container, m[8], m[9]);\n    }\n\n    if (m[10]) {\n      center.y = LENGTH_FOR_POSITION[m[10].toLowerCase()];\n    } else if (m[11] !== undefined) {\n      center.y = (0, _Length.calculateLengthFromValueWithUnit)(container, m[11], m[12]);\n    }\n  }\n\n  var gradientCenter = {\n    x: center.x === undefined ? bounds.width / 2 : center.x.getAbsoluteValue(bounds.width),\n    y: center.y === undefined ? bounds.height / 2 : center.y.getAbsoluteValue(bounds.height)\n  };\n  var gradientRadius = calculateRadius(m && m[2] || 'farthest-corner', shape, gradientCenter, radius, bounds);\n  return new RadialGradient(parseColorStops(args, m ? 1 : 0, Math.min(gradientRadius.x, gradientRadius.y)), shape, gradientCenter, gradientRadius);\n};\n\nvar calculateGradientDirection = function calculateGradientDirection(radian, bounds) {\n  var width = bounds.width;\n  var height = bounds.height;\n  var HALF_WIDTH = width * 0.5;\n  var HALF_HEIGHT = height * 0.5;\n  var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));\n  var HALF_LINE_LENGTH = lineLength / 2;\n  var x0 = HALF_WIDTH + Math.sin(radian) * HALF_LINE_LENGTH;\n  var y0 = HALF_HEIGHT - Math.cos(radian) * HALF_LINE_LENGTH;\n  var x1 = width - x0;\n  var y1 = height - y0;\n  return {\n    x0: x0,\n    x1: x1,\n    y0: y0,\n    y1: y1\n  };\n};\n\nvar parseTopRight = function parseTopRight(bounds) {\n  return Math.acos(bounds.width / 2 / ((0, _Util.distance)(bounds.width, bounds.height) / 2));\n};\n\nvar parseSideOrCorner = function parseSideOrCorner(side, bounds) {\n  switch (side) {\n    case 'bottom':\n    case 'to top':\n      return calculateGradientDirection(0, bounds);\n\n    case 'left':\n    case 'to right':\n      return calculateGradientDirection(Math.PI / 2, bounds);\n\n    case 'right':\n    case 'to left':\n      return calculateGradientDirection(3 * Math.PI / 2, bounds);\n\n    case 'top right':\n    case 'right top':\n    case 'to bottom left':\n    case 'to left bottom':\n      return calculateGradientDirection(Math.PI + parseTopRight(bounds), bounds);\n\n    case 'top left':\n    case 'left top':\n    case 'to bottom right':\n    case 'to right bottom':\n      return calculateGradientDirection(Math.PI - parseTopRight(bounds), bounds);\n\n    case 'bottom left':\n    case 'left bottom':\n    case 'to top right':\n    case 'to right top':\n      return calculateGradientDirection(parseTopRight(bounds), bounds);\n\n    case 'bottom right':\n    case 'right bottom':\n    case 'to top left':\n    case 'to left top':\n      return calculateGradientDirection(2 * Math.PI - parseTopRight(bounds), bounds);\n\n    case 'top':\n    case 'to bottom':\n    default:\n      return calculateGradientDirection(Math.PI, bounds);\n  }\n};\n\nvar parsePercentageAngle = function parsePercentageAngle(angle, bounds) {\n  var _angle$split$map = angle.split(' ').map(parseFloat),\n      _angle$split$map2 = _slicedToArray(_angle$split$map, 2),\n      left = _angle$split$map2[0],\n      top = _angle$split$map2[1];\n\n  var ratio = left / 100 * bounds.width / (top / 100 * bounds.height);\n  return calculateGradientDirection(Math.atan(isNaN(ratio) ? 1 : ratio) + Math.PI / 2, bounds);\n};\n\nvar findCorner = function findCorner(bounds, x, y, closest) {\n  var corners = [{\n    x: 0,\n    y: 0\n  }, {\n    x: 0,\n    y: bounds.height\n  }, {\n    x: bounds.width,\n    y: 0\n  }, {\n    x: bounds.width,\n    y: bounds.height\n  }]; // $FlowFixMe\n\n  return corners.reduce(function (stat, corner) {\n    var d = (0, _Util.distance)(x - corner.x, y - corner.y);\n\n    if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {\n      return {\n        optimumCorner: corner,\n        optimumDistance: d\n      };\n    }\n\n    return stat;\n  }, {\n    optimumDistance: closest ? Infinity : -Infinity,\n    optimumCorner: null\n  }).optimumCorner;\n};\n\nvar calculateRadius = function calculateRadius(extent, shape, center, radius, bounds) {\n  var x = center.x;\n  var y = center.y;\n  var rx = 0;\n  var ry = 0;\n\n  switch (extent) {\n    case 'closest-side':\n      // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradient’s center.\n      // If the shape is an ellipse, it exactly meets the closest side in each dimension.\n      if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n        rx = ry = Math.min(Math.abs(x), Math.abs(x - bounds.width), Math.abs(y), Math.abs(y - bounds.height));\n      } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n        rx = Math.min(Math.abs(x), Math.abs(x - bounds.width));\n        ry = Math.min(Math.abs(y), Math.abs(y - bounds.height));\n      }\n\n      break;\n\n    case 'closest-corner':\n      // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradient’s center.\n      // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.\n      if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n        rx = ry = Math.min((0, _Util.distance)(x, y), (0, _Util.distance)(x, y - bounds.height), (0, _Util.distance)(x - bounds.width, y), (0, _Util.distance)(x - bounds.width, y - bounds.height));\n      } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n        // Compute the ratio ry/rx (which is to be the same as for \"closest-side\")\n        var c = Math.min(Math.abs(y), Math.abs(y - bounds.height)) / Math.min(Math.abs(x), Math.abs(x - bounds.width));\n        var corner = findCorner(bounds, x, y, true);\n        rx = (0, _Util.distance)(corner.x - x, (corner.y - y) / c);\n        ry = c * rx;\n      }\n\n      break;\n\n    case 'farthest-side':\n      // Same as closest-side, except the ending shape is sized based on the farthest side(s)\n      if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n        rx = ry = Math.max(Math.abs(x), Math.abs(x - bounds.width), Math.abs(y), Math.abs(y - bounds.height));\n      } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n        rx = Math.max(Math.abs(x), Math.abs(x - bounds.width));\n        ry = Math.max(Math.abs(y), Math.abs(y - bounds.height));\n      }\n\n      break;\n\n    case 'farthest-corner':\n      // Same as closest-corner, except the ending shape is sized based on the farthest corner.\n      // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.\n      if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n        rx = ry = Math.max((0, _Util.distance)(x, y), (0, _Util.distance)(x, y - bounds.height), (0, _Util.distance)(x - bounds.width, y), (0, _Util.distance)(x - bounds.width, y - bounds.height));\n      } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n        // Compute the ratio ry/rx (which is to be the same as for \"farthest-side\")\n        var _c = Math.max(Math.abs(y), Math.abs(y - bounds.height)) / Math.max(Math.abs(x), Math.abs(x - bounds.width));\n\n        var _corner = findCorner(bounds, x, y, false);\n\n        rx = (0, _Util.distance)(_corner.x - x, (_corner.y - y) / _c);\n        ry = _c * rx;\n      }\n\n      break;\n\n    default:\n      // pixel or percentage values\n      rx = radius.x || 0;\n      ry = radius.y !== undefined ? radius.y : rx;\n      break;\n  }\n\n  return {\n    x: rx,\n    y: ry\n  };\n};\n\nvar transformWebkitRadialGradientArgs = exports.transformWebkitRadialGradientArgs = function transformWebkitRadialGradientArgs(args) {\n  var shape = '';\n  var radius = '';\n  var extent = '';\n  var position = '';\n  var idx = 0;\n  var POSITION = /^(left|center|right|\\d+(?:px|r?em|%)?)(?:\\s+(top|center|bottom|\\d+(?:px|r?em|%)?))?$/i;\n  var SHAPE_AND_EXTENT = /^(circle|ellipse)?\\s*(closest-side|closest-corner|farthest-side|farthest-corner|contain|cover)?$/i;\n  var RADIUS = /^\\d+(px|r?em|%)?(?:\\s+\\d+(px|r?em|%)?)?$/i;\n  var matchStartPosition = args[idx].match(POSITION);\n\n  if (matchStartPosition) {\n    idx++;\n  }\n\n  var matchShapeExtent = args[idx].match(SHAPE_AND_EXTENT);\n\n  if (matchShapeExtent) {\n    shape = matchShapeExtent[1] || '';\n    extent = matchShapeExtent[2] || '';\n\n    if (extent === 'contain') {\n      extent = 'closest-side';\n    } else if (extent === 'cover') {\n      extent = 'farthest-corner';\n    }\n\n    idx++;\n  }\n\n  var matchStartRadius = args[idx].match(RADIUS);\n\n  if (matchStartRadius) {\n    idx++;\n  }\n\n  var matchEndPosition = args[idx].match(POSITION);\n\n  if (matchEndPosition) {\n    idx++;\n  }\n\n  var matchEndRadius = args[idx].match(RADIUS);\n\n  if (matchEndRadius) {\n    idx++;\n  }\n\n  var matchPosition = matchEndPosition || matchStartPosition;\n\n  if (matchPosition && matchPosition[1]) {\n    position = matchPosition[1] + (/^\\d+$/.test(matchPosition[1]) ? 'px' : '');\n\n    if (matchPosition[2]) {\n      position += ' ' + matchPosition[2] + (/^\\d+$/.test(matchPosition[2]) ? 'px' : '');\n    }\n  }\n\n  var matchRadius = matchEndRadius || matchStartRadius;\n\n  if (matchRadius) {\n    radius = matchRadius[0];\n\n    if (!matchRadius[1]) {\n      radius += 'px';\n    }\n  }\n\n  if (position && !shape && !radius && !extent) {\n    radius = position;\n    position = '';\n  }\n\n  if (position) {\n    position = 'at ' + position;\n  }\n\n  return [[shape, extent, radius, position].filter(function (s) {\n    return !!s;\n  }).join(' ')].concat(args.slice(idx));\n};\n\nvar transformObsoleteColorStops = function transformObsoleteColorStops(args) {\n  return args.map(function (color) {\n    return color.match(FROM_TO_COLORSTOP);\n  }) // $FlowFixMe\n  .map(function (v, index) {\n    if (!v) {\n      return args[index];\n    }\n\n    switch (v[1]) {\n      case 'from':\n        return v[4] + ' 0%';\n\n      case 'to':\n        return v[4] + ' 100%';\n\n      case 'color-stop':\n        if (v[3] === '%') {\n          return v[4] + ' ' + v[2];\n        }\n\n        return v[4] + ' ' + parseFloat(v[2]) * 100 + '%';\n    }\n  });\n};","map":{"version":3,"sources":["/Users/ChathushkaRodrigo/Desktop/ITP Project/ZooMelaka-Management-System/frontend/node_modules/react-to-pdf/node_modules/html2canvas/dist/npm/Gradient.js"],"names":["Object","defineProperty","exports","value","transformWebkitRadialGradientArgs","parseGradient","RadialGradient","LinearGradient","RADIAL_GRADIENT_SHAPE","GRADIENT_TYPE","undefined","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","TypeError","_NodeContainer","require","_NodeContainer2","_interopRequireDefault","_Angle","_Color","_Color2","_Length","_Length2","_Util","obj","__esModule","default","_classCallCheck","instance","Constructor","SIDE_OR_CORNER","PERCENTAGE_ANGLES","ENDS_WITH_LENGTH","FROM_TO_COLORSTOP","RADIAL_SHAPE_DEFINITION","LINEAR_GRADIENT","RADIAL_GRADIENT","CIRCLE","ELLIPSE","LENGTH_FOR_POSITION","left","top","center","right","bottom","colorStops","direction","type","shape","radius","container","_ref","bounds","args","method","prefix","parseLinearGradient","concat","transformObsoleteColorStops","slice","parseRadialGradient","parseColorStops","firstColorStopIndex","lineLength","HAS_LENGTH","test","lastSpaceIndex","lastIndexOf","_color","substring","_stop","color","stop","absoluteValuedColorStops","map","_ref2","absoluteStop","getAbsoluteValue","previousColorStop","_stop2","n","steps","nextColorStep","stepSize","hasPrefix","angle","parseAngle","HAS_SIDE_OR_CORNER","HAS_DIRECTION","calculateGradientDirection","Math","PI","parseSideOrCorner","parsePercentageAngle","min","distance","abs","x0","x1","y0","y1","width","height","m","match","x","calculateLengthFromValueWithUnit","y","toLowerCase","gradientCenter","gradientRadius","calculateRadius","radian","HALF_WIDTH","HALF_HEIGHT","sin","cos","HALF_LINE_LENGTH","parseTopRight","acos","side","_angle$split$map","split","parseFloat","_angle$split$map2","ratio","atan","isNaN","findCorner","closest","corners","reduce","stat","corner","d","optimumDistance","optimumCorner","Infinity","extent","rx","ry","c","max","_c","_corner","position","idx","POSITION","SHAPE_AND_EXTENT","RADIUS","matchStartPosition","matchShapeExtent","matchStartRadius","matchEndPosition","matchEndRadius","matchPosition","matchRadius","filter","s","join","v","index"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.transformWebkitRadialGradientArgs = exports.parseGradient = exports.RadialGradient = exports.LinearGradient = exports.RADIAL_GRADIENT_SHAPE = exports.GRADIENT_TYPE = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _NodeContainer = require('./NodeContainer');\n\nvar _NodeContainer2 = _interopRequireDefault(_NodeContainer);\n\nvar _Angle = require('./Angle');\n\nvar _Color = require('./Color');\n\nvar _Color2 = _interopRequireDefault(_Color);\n\nvar _Length = require('./Length');\n\nvar _Length2 = _interopRequireDefault(_Length);\n\nvar _Util = require('./Util');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SIDE_OR_CORNER = /^(to )?(left|top|right|bottom)( (left|top|right|bottom))?$/i;\nvar PERCENTAGE_ANGLES = /^([+-]?\\d*\\.?\\d+)% ([+-]?\\d*\\.?\\d+)%$/i;\nvar ENDS_WITH_LENGTH = /(px)|%|( 0)$/i;\nvar FROM_TO_COLORSTOP = /^(from|to|color-stop)\\((?:([\\d.]+)(%)?,\\s*)?(.+?)\\)$/i;\nvar RADIAL_SHAPE_DEFINITION = /^\\s*(circle|ellipse)?\\s*((?:([\\d.]+)(px|r?em|%)\\s*(?:([\\d.]+)(px|r?em|%))?)|closest-side|closest-corner|farthest-side|farthest-corner)?\\s*(?:at\\s*(?:(left|center|right)|([\\d.]+)(px|r?em|%))\\s+(?:(top|center|bottom)|([\\d.]+)(px|r?em|%)))?(?:\\s|$)/i;\n\nvar GRADIENT_TYPE = exports.GRADIENT_TYPE = {\n    LINEAR_GRADIENT: 0,\n    RADIAL_GRADIENT: 1\n};\n\nvar RADIAL_GRADIENT_SHAPE = exports.RADIAL_GRADIENT_SHAPE = {\n    CIRCLE: 0,\n    ELLIPSE: 1\n};\n\nvar LENGTH_FOR_POSITION = {\n    left: new _Length2.default('0%'),\n    top: new _Length2.default('0%'),\n    center: new _Length2.default('50%'),\n    right: new _Length2.default('100%'),\n    bottom: new _Length2.default('100%')\n};\n\nvar LinearGradient = exports.LinearGradient = function LinearGradient(colorStops, direction) {\n    _classCallCheck(this, LinearGradient);\n\n    this.type = GRADIENT_TYPE.LINEAR_GRADIENT;\n    this.colorStops = colorStops;\n    this.direction = direction;\n};\n\nvar RadialGradient = exports.RadialGradient = function RadialGradient(colorStops, shape, center, radius) {\n    _classCallCheck(this, RadialGradient);\n\n    this.type = GRADIENT_TYPE.RADIAL_GRADIENT;\n    this.colorStops = colorStops;\n    this.shape = shape;\n    this.center = center;\n    this.radius = radius;\n};\n\nvar parseGradient = exports.parseGradient = function parseGradient(container, _ref, bounds) {\n    var args = _ref.args,\n        method = _ref.method,\n        prefix = _ref.prefix;\n\n    if (method === 'linear-gradient') {\n        return parseLinearGradient(args, bounds, !!prefix);\n    } else if (method === 'gradient' && args[0] === 'linear') {\n        // TODO handle correct angle\n        return parseLinearGradient(['to bottom'].concat(transformObsoleteColorStops(args.slice(3))), bounds, !!prefix);\n    } else if (method === 'radial-gradient') {\n        return parseRadialGradient(container, prefix === '-webkit-' ? transformWebkitRadialGradientArgs(args) : args, bounds);\n    } else if (method === 'gradient' && args[0] === 'radial') {\n        return parseRadialGradient(container, transformObsoleteColorStops(transformWebkitRadialGradientArgs(args.slice(1))), bounds);\n    }\n};\n\nvar parseColorStops = function parseColorStops(args, firstColorStopIndex, lineLength) {\n    var colorStops = [];\n\n    for (var i = firstColorStopIndex; i < args.length; i++) {\n        var value = args[i];\n        var HAS_LENGTH = ENDS_WITH_LENGTH.test(value);\n        var lastSpaceIndex = value.lastIndexOf(' ');\n        var _color = new _Color2.default(HAS_LENGTH ? value.substring(0, lastSpaceIndex) : value);\n        var _stop = HAS_LENGTH ? new _Length2.default(value.substring(lastSpaceIndex + 1)) : i === firstColorStopIndex ? new _Length2.default('0%') : i === args.length - 1 ? new _Length2.default('100%') : null;\n        colorStops.push({ color: _color, stop: _stop });\n    }\n\n    var absoluteValuedColorStops = colorStops.map(function (_ref2) {\n        var color = _ref2.color,\n            stop = _ref2.stop;\n\n        var absoluteStop = lineLength === 0 ? 0 : stop ? stop.getAbsoluteValue(lineLength) / lineLength : null;\n\n        return {\n            color: color,\n            // $FlowFixMe\n            stop: absoluteStop\n        };\n    });\n\n    var previousColorStop = absoluteValuedColorStops[0].stop;\n    for (var _i = 0; _i < absoluteValuedColorStops.length; _i++) {\n        if (previousColorStop !== null) {\n            var _stop2 = absoluteValuedColorStops[_i].stop;\n            if (_stop2 === null) {\n                var n = _i;\n                while (absoluteValuedColorStops[n].stop === null) {\n                    n++;\n                }\n                var steps = n - _i + 1;\n                var nextColorStep = absoluteValuedColorStops[n].stop;\n                var stepSize = (nextColorStep - previousColorStop) / steps;\n                for (; _i < n; _i++) {\n                    previousColorStop = absoluteValuedColorStops[_i].stop = previousColorStop + stepSize;\n                }\n            } else {\n                previousColorStop = _stop2;\n            }\n        }\n    }\n\n    return absoluteValuedColorStops;\n};\n\nvar parseLinearGradient = function parseLinearGradient(args, bounds, hasPrefix) {\n    var angle = (0, _Angle.parseAngle)(args[0]);\n    var HAS_SIDE_OR_CORNER = SIDE_OR_CORNER.test(args[0]);\n    var HAS_DIRECTION = HAS_SIDE_OR_CORNER || angle !== null || PERCENTAGE_ANGLES.test(args[0]);\n    var direction = HAS_DIRECTION ? angle !== null ? calculateGradientDirection(\n    // if there is a prefix, the 0° angle points due East (instead of North per W3C)\n    hasPrefix ? angle - Math.PI * 0.5 : angle, bounds) : HAS_SIDE_OR_CORNER ? parseSideOrCorner(args[0], bounds) : parsePercentageAngle(args[0], bounds) : calculateGradientDirection(Math.PI, bounds);\n    var firstColorStopIndex = HAS_DIRECTION ? 1 : 0;\n\n    // TODO: Fix some inaccuracy with color stops with px values\n    var lineLength = Math.min((0, _Util.distance)(Math.abs(direction.x0) + Math.abs(direction.x1), Math.abs(direction.y0) + Math.abs(direction.y1)), bounds.width * 2, bounds.height * 2);\n\n    return new LinearGradient(parseColorStops(args, firstColorStopIndex, lineLength), direction);\n};\n\nvar parseRadialGradient = function parseRadialGradient(container, args, bounds) {\n    var m = args[0].match(RADIAL_SHAPE_DEFINITION);\n    var shape = m && (m[1] === 'circle' || // explicit shape specification\n    m[3] !== undefined && m[5] === undefined) // only one radius coordinate\n    ? RADIAL_GRADIENT_SHAPE.CIRCLE : RADIAL_GRADIENT_SHAPE.ELLIPSE;\n    var radius = {};\n    var center = {};\n\n    if (m) {\n        // Radius\n        if (m[3] !== undefined) {\n            radius.x = (0, _Length.calculateLengthFromValueWithUnit)(container, m[3], m[4]).getAbsoluteValue(bounds.width);\n        }\n\n        if (m[5] !== undefined) {\n            radius.y = (0, _Length.calculateLengthFromValueWithUnit)(container, m[5], m[6]).getAbsoluteValue(bounds.height);\n        }\n\n        // Position\n        if (m[7]) {\n            center.x = LENGTH_FOR_POSITION[m[7].toLowerCase()];\n        } else if (m[8] !== undefined) {\n            center.x = (0, _Length.calculateLengthFromValueWithUnit)(container, m[8], m[9]);\n        }\n\n        if (m[10]) {\n            center.y = LENGTH_FOR_POSITION[m[10].toLowerCase()];\n        } else if (m[11] !== undefined) {\n            center.y = (0, _Length.calculateLengthFromValueWithUnit)(container, m[11], m[12]);\n        }\n    }\n\n    var gradientCenter = {\n        x: center.x === undefined ? bounds.width / 2 : center.x.getAbsoluteValue(bounds.width),\n        y: center.y === undefined ? bounds.height / 2 : center.y.getAbsoluteValue(bounds.height)\n    };\n    var gradientRadius = calculateRadius(m && m[2] || 'farthest-corner', shape, gradientCenter, radius, bounds);\n\n    return new RadialGradient(parseColorStops(args, m ? 1 : 0, Math.min(gradientRadius.x, gradientRadius.y)), shape, gradientCenter, gradientRadius);\n};\n\nvar calculateGradientDirection = function calculateGradientDirection(radian, bounds) {\n    var width = bounds.width;\n    var height = bounds.height;\n    var HALF_WIDTH = width * 0.5;\n    var HALF_HEIGHT = height * 0.5;\n    var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));\n    var HALF_LINE_LENGTH = lineLength / 2;\n\n    var x0 = HALF_WIDTH + Math.sin(radian) * HALF_LINE_LENGTH;\n    var y0 = HALF_HEIGHT - Math.cos(radian) * HALF_LINE_LENGTH;\n    var x1 = width - x0;\n    var y1 = height - y0;\n\n    return { x0: x0, x1: x1, y0: y0, y1: y1 };\n};\n\nvar parseTopRight = function parseTopRight(bounds) {\n    return Math.acos(bounds.width / 2 / ((0, _Util.distance)(bounds.width, bounds.height) / 2));\n};\n\nvar parseSideOrCorner = function parseSideOrCorner(side, bounds) {\n    switch (side) {\n        case 'bottom':\n        case 'to top':\n            return calculateGradientDirection(0, bounds);\n        case 'left':\n        case 'to right':\n            return calculateGradientDirection(Math.PI / 2, bounds);\n        case 'right':\n        case 'to left':\n            return calculateGradientDirection(3 * Math.PI / 2, bounds);\n        case 'top right':\n        case 'right top':\n        case 'to bottom left':\n        case 'to left bottom':\n            return calculateGradientDirection(Math.PI + parseTopRight(bounds), bounds);\n        case 'top left':\n        case 'left top':\n        case 'to bottom right':\n        case 'to right bottom':\n            return calculateGradientDirection(Math.PI - parseTopRight(bounds), bounds);\n        case 'bottom left':\n        case 'left bottom':\n        case 'to top right':\n        case 'to right top':\n            return calculateGradientDirection(parseTopRight(bounds), bounds);\n        case 'bottom right':\n        case 'right bottom':\n        case 'to top left':\n        case 'to left top':\n            return calculateGradientDirection(2 * Math.PI - parseTopRight(bounds), bounds);\n        case 'top':\n        case 'to bottom':\n        default:\n            return calculateGradientDirection(Math.PI, bounds);\n    }\n};\n\nvar parsePercentageAngle = function parsePercentageAngle(angle, bounds) {\n    var _angle$split$map = angle.split(' ').map(parseFloat),\n        _angle$split$map2 = _slicedToArray(_angle$split$map, 2),\n        left = _angle$split$map2[0],\n        top = _angle$split$map2[1];\n\n    var ratio = left / 100 * bounds.width / (top / 100 * bounds.height);\n\n    return calculateGradientDirection(Math.atan(isNaN(ratio) ? 1 : ratio) + Math.PI / 2, bounds);\n};\n\nvar findCorner = function findCorner(bounds, x, y, closest) {\n    var corners = [{ x: 0, y: 0 }, { x: 0, y: bounds.height }, { x: bounds.width, y: 0 }, { x: bounds.width, y: bounds.height }];\n\n    // $FlowFixMe\n    return corners.reduce(function (stat, corner) {\n        var d = (0, _Util.distance)(x - corner.x, y - corner.y);\n        if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {\n            return {\n                optimumCorner: corner,\n                optimumDistance: d\n            };\n        }\n\n        return stat;\n    }, {\n        optimumDistance: closest ? Infinity : -Infinity,\n        optimumCorner: null\n    }).optimumCorner;\n};\n\nvar calculateRadius = function calculateRadius(extent, shape, center, radius, bounds) {\n    var x = center.x;\n    var y = center.y;\n    var rx = 0;\n    var ry = 0;\n\n    switch (extent) {\n        case 'closest-side':\n            // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradient’s center.\n            // If the shape is an ellipse, it exactly meets the closest side in each dimension.\n            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n                rx = ry = Math.min(Math.abs(x), Math.abs(x - bounds.width), Math.abs(y), Math.abs(y - bounds.height));\n            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n                rx = Math.min(Math.abs(x), Math.abs(x - bounds.width));\n                ry = Math.min(Math.abs(y), Math.abs(y - bounds.height));\n            }\n            break;\n\n        case 'closest-corner':\n            // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradient’s center.\n            // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.\n            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n                rx = ry = Math.min((0, _Util.distance)(x, y), (0, _Util.distance)(x, y - bounds.height), (0, _Util.distance)(x - bounds.width, y), (0, _Util.distance)(x - bounds.width, y - bounds.height));\n            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n                // Compute the ratio ry/rx (which is to be the same as for \"closest-side\")\n                var c = Math.min(Math.abs(y), Math.abs(y - bounds.height)) / Math.min(Math.abs(x), Math.abs(x - bounds.width));\n                var corner = findCorner(bounds, x, y, true);\n                rx = (0, _Util.distance)(corner.x - x, (corner.y - y) / c);\n                ry = c * rx;\n            }\n            break;\n\n        case 'farthest-side':\n            // Same as closest-side, except the ending shape is sized based on the farthest side(s)\n            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n                rx = ry = Math.max(Math.abs(x), Math.abs(x - bounds.width), Math.abs(y), Math.abs(y - bounds.height));\n            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n                rx = Math.max(Math.abs(x), Math.abs(x - bounds.width));\n                ry = Math.max(Math.abs(y), Math.abs(y - bounds.height));\n            }\n            break;\n\n        case 'farthest-corner':\n            // Same as closest-corner, except the ending shape is sized based on the farthest corner.\n            // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.\n            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {\n                rx = ry = Math.max((0, _Util.distance)(x, y), (0, _Util.distance)(x, y - bounds.height), (0, _Util.distance)(x - bounds.width, y), (0, _Util.distance)(x - bounds.width, y - bounds.height));\n            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {\n                // Compute the ratio ry/rx (which is to be the same as for \"farthest-side\")\n                var _c = Math.max(Math.abs(y), Math.abs(y - bounds.height)) / Math.max(Math.abs(x), Math.abs(x - bounds.width));\n                var _corner = findCorner(bounds, x, y, false);\n                rx = (0, _Util.distance)(_corner.x - x, (_corner.y - y) / _c);\n                ry = _c * rx;\n            }\n            break;\n\n        default:\n            // pixel or percentage values\n            rx = radius.x || 0;\n            ry = radius.y !== undefined ? radius.y : rx;\n            break;\n    }\n\n    return {\n        x: rx,\n        y: ry\n    };\n};\n\nvar transformWebkitRadialGradientArgs = exports.transformWebkitRadialGradientArgs = function transformWebkitRadialGradientArgs(args) {\n    var shape = '';\n    var radius = '';\n    var extent = '';\n    var position = '';\n    var idx = 0;\n\n    var POSITION = /^(left|center|right|\\d+(?:px|r?em|%)?)(?:\\s+(top|center|bottom|\\d+(?:px|r?em|%)?))?$/i;\n    var SHAPE_AND_EXTENT = /^(circle|ellipse)?\\s*(closest-side|closest-corner|farthest-side|farthest-corner|contain|cover)?$/i;\n    var RADIUS = /^\\d+(px|r?em|%)?(?:\\s+\\d+(px|r?em|%)?)?$/i;\n\n    var matchStartPosition = args[idx].match(POSITION);\n    if (matchStartPosition) {\n        idx++;\n    }\n\n    var matchShapeExtent = args[idx].match(SHAPE_AND_EXTENT);\n    if (matchShapeExtent) {\n        shape = matchShapeExtent[1] || '';\n        extent = matchShapeExtent[2] || '';\n        if (extent === 'contain') {\n            extent = 'closest-side';\n        } else if (extent === 'cover') {\n            extent = 'farthest-corner';\n        }\n        idx++;\n    }\n\n    var matchStartRadius = args[idx].match(RADIUS);\n    if (matchStartRadius) {\n        idx++;\n    }\n\n    var matchEndPosition = args[idx].match(POSITION);\n    if (matchEndPosition) {\n        idx++;\n    }\n\n    var matchEndRadius = args[idx].match(RADIUS);\n    if (matchEndRadius) {\n        idx++;\n    }\n\n    var matchPosition = matchEndPosition || matchStartPosition;\n    if (matchPosition && matchPosition[1]) {\n        position = matchPosition[1] + (/^\\d+$/.test(matchPosition[1]) ? 'px' : '');\n        if (matchPosition[2]) {\n            position += ' ' + matchPosition[2] + (/^\\d+$/.test(matchPosition[2]) ? 'px' : '');\n        }\n    }\n\n    var matchRadius = matchEndRadius || matchStartRadius;\n    if (matchRadius) {\n        radius = matchRadius[0];\n        if (!matchRadius[1]) {\n            radius += 'px';\n        }\n    }\n\n    if (position && !shape && !radius && !extent) {\n        radius = position;\n        position = '';\n    }\n\n    if (position) {\n        position = 'at ' + position;\n    }\n\n    return [[shape, extent, radius, position].filter(function (s) {\n        return !!s;\n    }).join(' ')].concat(args.slice(idx));\n};\n\nvar transformObsoleteColorStops = function transformObsoleteColorStops(args) {\n    return args.map(function (color) {\n        return color.match(FROM_TO_COLORSTOP);\n    })\n    // $FlowFixMe\n    .map(function (v, index) {\n        if (!v) {\n            return args[index];\n        }\n\n        switch (v[1]) {\n            case 'from':\n                return v[4] + ' 0%';\n            case 'to':\n                return v[4] + ' 100%';\n            case 'color-stop':\n                if (v[3] === '%') {\n                    return v[4] + ' ' + v[2];\n                }\n                return v[4] + ' ' + parseFloat(v[2]) * 100 + '%';\n        }\n    });\n};"]},"metadata":{},"sourceType":"script"}